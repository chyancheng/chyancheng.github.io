<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[chyancheng]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://chyancheng.github.io/"/>
  <updated>2015-11-15T10:09:53.344Z</updated>
  <id>http://chyancheng.github.io/</id>
  
  <author>
    <name><![CDATA[chyancheng]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于this]]></title>
    <link href="http://chyancheng.github.io/2015/11/15/%E5%85%B3%E4%BA%8Ethis/"/>
    <id>http://chyancheng.github.io/2015/11/15/关于this/</id>
    <published>2015-11-15T10:09:53.344Z</published>
    <updated>2015-11-15T10:09:53.344Z</updated>
    <content type="html"><![CDATA[<p>《你不知道的Javascript》的第二部分[this]的读书笔记<br><a id="more"></a></p>
<hr>
<p>首先需要明确的是：<br>this在<strong>函数调用时被绑定</strong>而不是函数声明时，<br>因此判断this绑定的对象时要找到<strong>函数体的调用位置</strong>。</p>
<h2 id="this的绑定规则">this的绑定规则</h2><h3 id="1-[隐式绑定]作为对象的方法调用,this指向该对象">1.[隐式绑定]作为对象的方法调用,this指向该对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>值得注意的情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2:obj2</span><br><span class="line">&#125;;</span><br><span class="line">dbj1.obj2.foo(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure></p>
<p>这里foo()的this绑定obj2，因为对象属性引用链的最后一层影响调用位置。</p>
<h3 id="2-[默认绑定]不带任何修饰的函数调用,_this默认绑定全局对象_（严格模式下不会默认绑定全局对象，this绑定undefined）">2.[默认绑定]不带任何修饰的函数调用, this默认绑定全局对象 （严格模式下不会默认绑定全局对象，this绑定undefined）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure>
<p>值得注意的情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>;</span><br><span class="line">bar(); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure></p>
<p>bar是obj.foo的引用，但此时bar()是一个不带任何修饰的函数调用，因此应用默认绑定。</p>
<p>更需要注意的一种情况发生在传入回调函数时:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span><span class="params">(fn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fn其实引用的是foo</span></span><br><span class="line">    fn(); <span class="comment">//这里是调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>;</span><br><span class="line">doFoo(obj.foo); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure></p>
<p>函数的参数传递是一种隐式赋值，所以结果和上例一样，默认绑定到全局对象。</p>
<h3 id="3-[显式绑定]通过apply/call调用_this指向指定对象。">3.[显式绑定]通过apply/call调用 this指向指定对象。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>从this绑定角度来说,call/apply是一样的。</p>
<p>值得注意的情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.call(<span class="literal">null</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>如果把null或者undefined作为this的绑定对象传入call/apply时，会被忽略，应用默认绑定</p>
<h3 id="4-[new绑定]new操作符_this指向新对象">4.[new绑定]new操作符 this指向新对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="判断this,按照下面顺序判断"><strong>判断this,按照下面顺序判断</strong></h2><ol>
<li>函数是否在new中调用(new绑定)？ 是的话this绑定新创建的对象<br>var bar = new foo()</li>
<li>函数是否通过call/apply(显式绑定)或者硬绑定？ 是的话this绑定指定的对象<br>var bar = foo.call(obj2)</li>
<li>函数是否在某个上下文对象中调用(隐式绑定)？ 是的话this绑定那个上下文对象<br>var bar = obj1.foo()</li>
<li>如果都不是就使用默认绑定，严格模式下绑定到undefined，否则绑定到全局对象<br>var bar = foo()</li>
</ol>
<hr>
<h2 id="一些特别注意">一些特别注意</h2><h3 id="*箭头函数_=&gt;">*箭头函数 =&gt;</h3><p>ES6中的箭头函数不适用上述规则判读this绑定的对象，而是根据外层(函数或者全局)作用域来决定this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>foo()内部创建的箭头函数会捕获调用时foo()的this,由于foo()的this绑定到obj1,bar(所返回的箭头函数)的this也绑定到obj1，箭头函数的绑定无法修改(new也不行)</p>
<h3 id="**DOM">**DOM</h3><p>在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点(除非通过bind切换了上下文)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).addEventListener(<span class="string">"click"</span>,<span class="keyword">this</span>.handleClick);</span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> Listener();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click(); <span class="comment">//logs "&lt;div id="foo"&gt;&lt;/div&gt;"</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考：<br>《你不知道的javascript》第二部分[关于this] [this全面解析]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《你不知道的Javascript》的第二部分[this]的读书笔记<br>]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://chyancheng.github.io/tags/Javascript/"/>
    
      <category term="前端" scheme="http://chyancheng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript内部原理——变量对象(Variable object)]]></title>
    <link href="http://chyancheng.github.io/2015/08/06/Javascript%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1(Variable%20object)/"/>
    <id>http://chyancheng.github.io/2015/08/06/Javascript内部原理——变量对象(Variable object)/</id>
    <published>2015-08-05T16:00:00.000Z</published>
    <updated>2015-08-09T03:04:47.169Z</updated>
    <content type="html"><![CDATA[<p>我们真的了解 Javascript 的内部工作原理吗？</p>
<p>下面几个问题可以检验一下。<br><a id="more"></a></p>
<hr>
<h2 id="Questions">Questions</h2><h3 id="Q1">Q1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="Q2">Q2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">        x &amp;&amp; a(--x);</span><br><span class="line">    &#125;;</span><br><span class="line">alert(a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h3 id="Q3">Q3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(a);<span class="comment">//function a(x) &#123;return x * 2;&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="处理上下文代码">处理上下文代码</h2><p>要想理解上面问题的执行结果的原因，需要先理解 Javascript 是如何处理执行上下文代码。</p>
<p>处理执行上下文代码分为两个阶段：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<h3 id="进入执行上下文">进入执行上下文</h3><p>先了解一个概念<strong>变量对象(Variable object)</strong>，它是一个与执行上下文有关的特殊的对象，它包括：</p>
<ol>
<li>变量声明(var)</li>
<li>函数声明(FD)</li>
<li>函数形参在上下文中的声明</li>
</ol>
<p>一般用 VO = { } 表示变量对象。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line">test(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码对应的变量对象(VO)则如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局上下文中的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  test: </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// “test”函数上下文中的变量对象</span></span><br><span class="line">VO(test functionContext) = &#123;</span><br><span class="line">  x: <span class="number">30</span>,</span><br><span class="line">  b: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当进入执行上下文时，变量对象(VO)会依次被下列属性填充：</p>
<ol>
<li><p>函数的形参<br>—— 其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined。</p>
</li>
<li><p>函数声明(FD)<br>—— 其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值。</p>
</li>
<li><p>变量声明(var)<br>—— 其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。</p>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>当以10为参数进入“test”函数上下文的时候，对应的AO如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AO(test) = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="literal">undefined</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">  d: <span class="xml"><span class="tag">&lt;<span class="title">reference</span> <span class="attribute">to</span> <span class="attribute">FunctionDeclaration</span> "<span class="attribute">d</span>"&gt;</span>,</span><br><span class="line">  e: undefined</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>注意，上面的AO并不包含函数“x”。这是因为这里的“x”并不是函数声明而是函数表达式（FunctionExpression），函数表达式不会对VO造成影响。 尽管函数“_e”也是函数表达式，然而，由于它被赋值给了变量“e”，因此它可以通过“e”来访问到。</p>
<p>这样，第一阶段<strong>进入执行上下文</strong>就结束了，接下来是第二阶段<strong>执行代码</strong>。</p>
<h3 id="执行代码">执行代码</h3><p>这时的变量对象(VO)的属性已经被填充好了（大多数值仍未undefined），在执行代码阶段，变量对象(VO)会被修改为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</span><br><span class="line">AO[<span class="string">'e'</span>] = <span class="xml"><span class="tag">&lt;<span class="title">reference</span> <span class="attribute">to</span> <span class="attribute">FunctionExpression</span> "<span class="attribute">_e</span>"&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>看一个更典型的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(x); <span class="comment">// function x()&#123;&#125; </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10 </span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>根据规则，在进入上下文的时候，VO会首先被填充函数声明； 同一阶段，还有变量声明“x”，但是，正如此前提到的，变量声明是在函数形参和函数声明之后，并且，变量声明不会对已经存在的同样名字的函数形参和函数声明发生冲突， 因此，在<strong>进入执行上下文</strong>的阶段，VO填充为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="title">reference</span> <span class="attribute">to</span> <span class="attribute">FunctionDeclaration</span> "<span class="attribute">x</span>"&gt;</span>;</span></span><br><span class="line"><span class="comment">// 发现var x = 10;</span></span><br><span class="line"><span class="comment">// 如果函数“x”还未定义，则 "x" 为undefined, 但是在我们的例子中已经有了函数声明“x”;</span></span><br><span class="line"><span class="comment">// 所以变量声明并不会影响同名的函数值;</span></span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="title">reference</span> <span class="attribute">to</span> <span class="attribute">FunctionDeclaration</span> "<span class="attribute">x</span>"&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>随后，在<strong>执行代码</strong>阶段，VO被修改为如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined, but not "b is not defined"</span></span><br></pre></td></tr></table></figure>
<p>在<strong>进入执行上下文</strong>阶段，变量存储在VO中，因此，尽管else的代码块永远都不会执行到，但“b”却仍然在VO中，值为undefined，而不是报错。</p>
<hr>
<h2 id="回顾开始的问题">回顾开始的问题</h2><h3 id="Q1-1">Q1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>进入执行上下文： 创建VO，并填充变量声明 a，VO如下所示：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO(global) = &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行代码： 进入 if语句，发现条件判断 “a” in window 为 true。于是就不会进入if代码块，直接执行alert语句，因此，最终为undefined。</p>
</li>
</ol>
<h3 id="Q2-1">Q2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">        x &amp;&amp; a(--x);</span><br><span class="line">    &#125;;</span><br><span class="line">alert(a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>进入执行上下文： 注意， b = function a(){}，这里的 function a并非函数声明，因为整个这个句话属于赋值语句（assignment statement），所以，这里的 function a会被看作是函数表达式。 函数表达式是不会对VO造成影响的。所以，这个时候VO中其实只有 a和x（函数形参）：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO(global) = &#123;</span><br><span class="line">a: <span class="literal">undefined</span>,</span><br><span class="line">b: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行代码： 这个时候a的值修改为1:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO(global) = &#123;</span><br><span class="line">x: <span class="literal">undefined</span>,</span><br><span class="line">a: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Q3-1">Q3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(a);<span class="comment">//function a(x) &#123;return x * 2;&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>进入执行上下文： 根据变量对象(VO)介绍的，填充VO的顺序是: 函数的形参 -&gt; 函数声明 -&gt; 变量声明。变量a在函数a后面，那么，变量a遇到函数a怎么办呢？还是根据变量对象中介绍的，当变量声明遇到VO中已经有同名的时候，不会影响已经存在的属性。因此，VO如下所示：：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO(global) = &#123;</span><br><span class="line">a: <span class="xml"><span class="tag">&lt;<span class="title">reference</span> <span class="attribute">to</span> <span class="attribute">FunctionExpression</span> "<span class="attribute">x</span>"&gt;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行代码： 没变化，最终的结果是：函数a。</p>
</li>
</ol>
<hr>
<p>参考链接：</p>
<ol>
<li><a href="http://goddyzhao.tumblr.com/post/11478726832/do-i-really-understand-javascript" target="_blank" rel="external">JavaScript内部原理实践——真的懂JavaScript吗？</a></li>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object.</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们真的了解 Javascript 的内部工作原理吗？</p>
<p>下面几个问题可以检验一下。<br>]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://chyancheng.github.io/tags/Javascript/"/>
    
      <category term="前端" scheme="http://chyancheng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转载]详说 Block Formatting Contexts (块级格式化上下文)]]></title>
    <link href="http://chyancheng.github.io/2015/04/04/%E8%AF%A6%E8%AF%B4Block%20Formatting%20Contexts/"/>
    <id>http://chyancheng.github.io/2015/04/04/详说Block Formatting Contexts/</id>
    <published>2015-04-03T16:00:00.000Z</published>
    <updated>2015-04-04T13:40:05.000Z</updated>
    <content type="html"><![CDATA[<p>文章转载自<a href="http://kayosite.com/block-formatting-contexts-in-detail.html" target="_blank" rel="external">详说 Block Formatting Contexts (块级格式化上下文)</a><br>（原文基础上略有修改）。</p>
<p>前几天有小伙伴在讨论关于 BFC 的问题。查阅了一些资料博客。这篇博文讲解的十分详细。转载来作为一个归纳总结。<br><a id="more"></a></p>
<hr>
<h2 id="BFC_是什么">BFC 是什么</h2><p>首先， BFC 在CSS的定位方案中是属于普通流(Normal Flow)，所以它并不会对兄弟元素有什么影响（与浮动(Floats)和绝对定位(Absolute Positioning)相比）。</p>
<p>从样式上看，具有 BFC 的元素与普通的容器没有什么区别，但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，从而防止出现高度塌陷的问题。</p>
<p>简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。</p>
<hr>
<h2 id="如何触发_BFC">如何触发 BFC</h2><p>满足下面任一条件的元素，会触发为 BFC ：</p>
<ul>
<li>浮动元素，float 除 none 以外的值</li>
<li>绝对定位元素，position（absolute，fixed）</li>
<li>display 为以下其中之一的值 inline-blocks，table-cells，table-captions</li>
<li>overflow 除了 visible 以外的值（hidden，auto，scroll）, 除非该值已经扩散到了视口</li>
</ul>
<p>其中需要注意的是：<code>display:table</code> 本身并不产生 BFC，而是由它产生匿名框，匿名框中包含 <code>display:table-cell</code> 的框会产 BFC。 总之，对于 <code>display:table</code> 的元素，产生 BFC 的是匿名框而不是 <code>display:table</code>。</p>
<p>另需注意：当body设置 <code>overflow:hidden</code> 时，并不会产生 BFC ,需要同时给HTML设置 <code>overflow:hidden</code> 或者给body加上 <code>display:table</code> 、 <code>display:inline-block</code> 、 <code>position:absolute</code> ，才能成功的产生BFC。</p>
<p>在 CSS3 中，BFC 叫做 Flow Root，并增加了一些触发条件：</p>
<ul>
<li>display 的 table-caption 值</li>
<li>position 的 fixed 值，其实 fixed 是 absolute 的一个子类，因此在 CSS2.1 中使用这个值也会触发 BFC ，只是在 CSS3 中更加明确了这一点。</li>
</ul>
<p>记住，BFC 并不是元素，而是某些元素带有的一些属性。因此，是上面这些元素产生了 BFC ，而它们本身并不是 BFC ，这个概念需要区分清楚 。</p>
<hr>
<h2 id="BFC_的特性">BFC 的特性</h2><p>从整体上看，BFC 是隔离了的容器，这个具体可以表现为三个特性：</p>
<h3 id="BFC_会阻止外边距折叠">BFC 会阻止外边距折叠</h3><p>在举例说明 BFC 如何阻止外边距折叠之前，首先说明一下外边距折叠的规则：仅当两个块级元素相邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。因此，阻止外边距折叠只需产生新的 BFC 。</p>
<p>效果如图：</p>
<p><img src="http://kayosite.com/wp-content/uploads/2012/10/bfc-1.png" alt="1"></p>
<p>代码如下：</p>
<p>HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我是一个段落，在我以及我的父元素上同时添加了上下的外边距<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我是一个段落，在我以及我的父元素上同时添加了上下的外边距<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"overflow:hidden"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我是一个段落，在我以及我的父元素上同时添加了上下的外边距(我没有产生边距折叠)<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*<span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff9900</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上图的例子，三个 div 各包含一个 p 元素，三个 div 及其包含的 p 元素都有顶部和底部的外边距，但只有第三个 div 的边距没有与它的子元素 p 的外边距折叠。这是因为第三个 div 创建了新的 BFC ，由此可见：创建了 BFC 的元素，不和它的子元素发生外边距折叠。</p>
<h3 id="BFC_可以包含浮动的元素">BFC 可以包含浮动的元素</h3><p>这也正是使用 overflow: hidden 与 overflow: auto 方法闭合浮动的原理，使用 overflow: hidden 或 overflow: auto 触发浮动元素的父元素的 BFC 特性，从而可以包含浮动元素，闭合浮动。</p>
<p>W3C 的原文是“’Auto’ heights for block formatting context roots”，也就是 BFC 会根据子元素的情况自动适应高度，即使其子元素中包括浮动元素。</p>
<p>效果如图：</p>
<p><img src="http://kayosite.com/wp-content/uploads/2012/10/bfc-2.png" alt="2"></p>
<p>代码如下：</p>
<p>HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我设置了左浮动 float: left, 但是我的父元素没有触发 BFC<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"overflow:hidden"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我设置了左浮动 float: left, 而且我的父元素触发了 BFC<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*<span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="tag">div</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1000px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">4px</span> solid <span class="hexcolor">#9a9a9a</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff9900</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，有两个 div ，它们各包含一个设置了浮动的 p 元素，但第一个 div 出现了“高度塌陷”，这是因为内部的浮动元素脱离了普通流，因此该 div 相当于一个空标签，没有高度和宽度，即高度为 0 ，上下边框也重叠在一起。而第二个 div 使用 overflow: hidden 触发了 BFC ，可以包含浮动元素，因此能正确表现出高度，其边框位置也正常了。</p>
<h3 id="BFC_可以阻止元素被浮动元素覆盖">BFC 可以阻止元素被浮动元素覆盖</h3><p>浮动元素的块级兄弟元素会无视浮动元素的位置，尽量占满一整行，这样就会被浮动元素覆盖，为该兄弟元素触发 BFC 后可以阻止这种情况的发生。</p>
<p>效果如图：</p>
<p><img src="http://kayosite.com/wp-content/uploads/2012/10/bfc-31.png" alt="3"></p>
<p>代码如下：</p>
<p>HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"main"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我设置了 float: left; width: 200px;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"aside"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我没有设置浮动，也没有触发 BFC ，width: 300px;background-color: #2595e5;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"main"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我设置了 float: left; width: 200px;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"aside"</span> <span class="attribute">style</span>=<span class="value">"overflow:hidden"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">p</span>&gt;</span>我没有设置浮动, 我触发了 BFC ，width: 300px;background-color: #2595e5;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*<span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.main</span> <span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ff9900</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.aside</span> <span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#2595e5</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上图的下一个例子，蓝色背景的 div 使用 overflow: hidden 触发了 BFC ，它并不会被它的兄弟浮动元素覆盖，而是处于它的旁边。值得注意的是，以上的情况仅仅是元素宽度之和没有超出父元素宽度的情况，假设浮动元素宽度和它的非浮动兄弟元素宽度都没有超过父元素宽度，但两个元素的宽度加起来超出了父元素宽度的时候，非浮动元素会下降到下一行，即处于浮动元素下方，效果如下图：</p>
<p><img src="http://kayosite.com/wp-content/uploads/2012/10/bfc-4.png" alt="4"></p>
<hr>
<p>本文转载自 Kayo Lee 博客，原文链接：<a href="http://kayosite.com/block-formatting-contexts-in-detail.html" target="_blank" rel="external">详说 Block Formatting Contexts (块级格式化上下文)</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>文章转载自<a href="http://kayosite.com/block-formatting-contexts-in-detail.html">详说 Block Formatting Contexts (块级格式化上下文)</a><br>（原文基础上略有修改）。</p>
<p>前几天有小伙伴在讨论关于 BFC 的问题。查阅了一些资料博客。这篇博文讲解的十分详细。转载来作为一个归纳总结。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://chyancheng.github.io/tags/CSS/"/>
    
      <category term="前端" scheme="http://chyancheng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[:target 伪类]]></title>
    <link href="http://chyancheng.github.io/2015/03/22/target-%E4%BC%AA%E7%B1%BB/"/>
    <id>http://chyancheng.github.io/2015/03/22/target-伪类/</id>
    <published>2015-03-21T16:00:00.000Z</published>
    <updated>2015-03-22T06:44:59.000Z</updated>
    <content type="html"><![CDATA[<p>首先，来看一个<a href="http://7.mywebwork.sinaapp.com" target="_blank" rel="external">demo</a>。</p>
<p>这是由纯CSS完成的一个动画效果，其中的关键是运用了CSS3的<code>transition</code>（过渡）属性配合<code>:target</code>伪类实现。<br><a id="more"></a></p>
<hr>
<h2 id="如何使用:target">如何使用<code>:target</code></h2><p>HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"voters"</span>&gt;</span> </span><br><span class="line">   Content</span><br><span class="line"><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#voters</span><span class="pseudo">:target</span> <span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">background</span>:<span class="value"> yellow</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>当点击页面中的一个链接并跳转至相应位置后，页面的URL发生改变，触发<code>:target</code>的CSS样式。</p>
<p>例如：</p>
<p><img src="http://7xi66m.com1.z0.glb.clouddn.com/：target_pic1.png" alt="URL_hash"></p>
<p>点击<code>&lt;a href=&quot;#voters&quot;&gt;voters&lt;/a&gt;</code>链接后，页面跳转至<code>#voters</code>，URL如上图显示时，则触发<code>#voters</code>下<code>:target</code>的CSS样式，将<code>#voters</code>的背景色变为黄色。</p>
<p>当然，链接的目标区域也可以设置<code>class</code>类名。当页面跳转至目标区域后，<br>同样可以触发<code>.className:target</code>的CSS样式，如<a href="http://7.mywebwork.sinaapp.com" target="_blank" rel="external">demo</a>。</p>
<hr>
<h2 id="何时使用:target">何时使用<code>:target</code></h2><blockquote>
<p>I’d use these rules-of-thumb for when <code>:target</code> is a good choice:</p>
<ol>
<li>When a “state” is needed</li>
<li>When the jump-down behavior is acceptable</li>
<li>When it’s acceptable to affect the browser history</li>
</ol>
</blockquote>
<p>下列情况适合使用<code>:target</code>：</p>
<ol>
<li>当页面跳转后，CSS需要有相应的改变。</li>
<li>页面跳转能够实现。</li>
<li>能够接受其对浏览器的历史记录的影响。</li>
</ol>
<p>适合使用在导航栏与目标区域上。当点击导航栏跳转时，相应区域触发<code>:target</code>样式。</p>
<hr>
<h2 id="参考链接">参考链接</h2><p><a href="https://css-tricks.com/on-target/" target="_blank" rel="external">On :target|CSS-Tricks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先，来看一个<a href="http://7.mywebwork.sinaapp.com">demo</a>。</p>
<p>这是由纯CSS完成的一个动画效果，其中的关键是运用了CSS3的<code>transition</code>（过渡）属性配合<code>:target</code>伪类实现。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://chyancheng.github.io/tags/CSS/"/>
    
      <category term="前端" scheme="http://chyancheng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <link href="http://chyancheng.github.io/2015/03/18/hello-hexo/"/>
    <id>http://chyancheng.github.io/2015/03/18/hello-hexo/</id>
    <published>2015-03-17T16:00:00.000Z</published>
    <updated>2015-03-22T07:43:58.000Z</updated>
    <content type="html"><![CDATA[<p>利用hexo搭建的静态博客。参考教程<a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>利用hexo搭建的静态博客。参考教程<a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Git]]>
    </summary>
    
      <category term="blog" scheme="http://chyancheng.github.io/tags/blog/"/>
    
      <category term="life" scheme="http://chyancheng.github.io/tags/life/"/>
    
  </entry>
  
</feed>